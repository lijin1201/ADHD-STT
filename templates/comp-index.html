<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>Multi Transcriber</title>
    </head>
    <body>
        <h2>Audio Transcription Comparison</h2>
        <div id="status">Connecting...</div>
        <table border="1">
            <thead>
                <tr><th>File / Action</th><th>Server 1</th><th>Server 2</th></tr>
            </thead>
            <tbody>{{file_list_html | safe}}</tbody>
        </table>

        <script>
            // const server1WS = new WebSocket("ws://localhost:10181/ws/adhd");
            // const server2WS = new WebSocket("ws://localhost:10181/ws/general");
            const serverIPs = ['localhost:11181', '192.168.3.19:11181'];
            const statusElem = document.getElementById('status');
            let server1WS = null;
            // let server2WS = null;
            let resolved = false;
            const sockets = [];
            const TIMEOUT_MS = 5000;

            const timeout = setTimeout(() => {
                if (!resolved) {
                    // resolved = true;
                    // Close all sockets still trying
                    sockets.forEach(ws => {
                        if (ws.readyState === WebSocket.CONNECTING) ws.close();
                    });
                    statusElem.textContent = 'Failed to connect wss server';
                }
            }, TIMEOUT_MS);

            serverIPs.forEach((url, idx) => {
                const ws = new WebSocket('wss://' + url + '/ws/adhd');
                sockets.push(ws);

                ws.onopen = () => {
                    if (!resolved) {
                        resolved = true;
                        server1WS = ws;
                        // Close the other socket if it's still connecting
                        sockets.forEach((otherWs, otherIdx) => {
                            if (otherIdx !== idx && otherWs.readyState === WebSocket.CONNECTING) {
                                otherWs.close();
                            }
                        });
                        // console.log(`Connected to ${url}`);
                        statusElem.textContent = `Connected: ${ws.url}`;
                        // Proceed using chosenSocket
                    }
                };

                ws.onerror = (err) => {
                    // // Optionally handle error
                    // if (!resolved && sockets.every(s => s.readyState !== WebSocket.OPEN && s.readyState !== WebSocket.CONNECTING)) {
                    // // All connections failed
                    // console.error('All WebSocket servers are unreachable.');
                    // }
                };

                ws.onclose = () => {
                    // Optionally handle close
                };
            });

            // const server1WS = new WebSocket("wss://localhost:11181/ws/adhd");
            // const server1WS = chosenSocket;
            const server2WS = new WebSocket("wss://localhost:11181/ws/general");

            function sendToBothServers(audioBlob, rowEl) {
                const readers = [new FileReader(), new FileReader()];

                readers.forEach((reader, idx) => {
                    reader.onload = () => {
                        const arrayBuffer = reader.result;
                        if (idx === 0) server1WS.send(arrayBuffer);
                        if (idx === 1) server2WS.send(arrayBuffer);
                    };
                    reader.readAsArrayBuffer(audioBlob);
                });

                server1WS.onmessage = (e) => rowEl.querySelector(".server1-result").textContent = e.data;
                server2WS.onmessage = (e) => rowEl.querySelector(".server2-result").textContent = e.data;
            }

            async function fetchAndSendAudio(file, rowEl) {
                const response = await fetch(`/static/audios/${file}`);
                const blob = await response.blob();
                const audio = new Audio(URL.createObjectURL(blob));
                audio.play();
                sendToBothServers(blob, rowEl);
            }

            async function recordAndSend(rowEl) {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mediaRecorder = new MediaRecorder(stream);
                let chunks = [];

                mediaRecorder.ondataavailable = (e) => chunks.push(e.data);

                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    sendToBothServers(blob, rowEl);
                };

                mediaRecorder.start();
                setTimeout(() => mediaRecorder.stop(), 3000);
            }

            document.addEventListener("DOMContentLoaded", () => {
                document.querySelectorAll(".playBtn").forEach(btn => {
                    btn.addEventListener("click", (e) => {
                        const row = e.target.closest("tr");
                        const file = row.getAttribute("data-file");
                        fetchAndSendAudio(file, row);
                    });
                });

                document.querySelectorAll(".recordBtn").forEach(btn => {
                    btn.addEventListener("click", (e) => {
                        const row = e.target.closest("tr");
                        recordAndSend(row);
                    });
                });
            });
        </script>
    </body>
    </html>